[{"categories":null,"contents":"\rK a l e v\rK a l e v\rK a l e v\rK a l e v\r","permalink":"http://localhost:1313/page/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"http://localhost:1313/page/archives/","tags":null,"title":"Archives"},{"categories":null,"contents":"题目描述\r给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。\n返回包含原始树中所有最深节点的 最小子树 。\n如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。\n一个节点的 子树 是该节点加上它的所有后代的集合。\n示例 1：\r输入：root = [3,5,1,6,2,0,8,null,null,7,4] 输出：[2,7,4] 解释： 我们返回值为 2 的节点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的节点。 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。 思路\r考虑到最深的节点可能有多个\n首先考虑找到最深的叶子节点，可以用层序遍历找到所有最深的叶子节点 然后从这些最深的叶子节点开始，向上遍历，找到第一个公共祖先，这个公共祖先就是我们要找的最小子树的根节点 最后返回这个公共祖先作为结果 代码实现\r/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* subtreeWithAllDeepest(TreeNode* root) { vector\u0026lt;int\u0026gt; fa(501, -1), dleves; vector\u0026lt;TreeNode*\u0026gt; mp(501, nullptr); queue\u0026lt;TreeNode*\u0026gt; q, tmp; q.push(root); while (!q.empty()) { int sz = q.size(); dleves.clear(); while (sz--) { TreeNode* p = q.front(); q.pop(); dleves.push_back(p-\u0026gt;val); mp[p-\u0026gt;val] = p; if (p-\u0026gt;left){ q.push(p-\u0026gt;left); fa[p-\u0026gt;left-\u0026gt;val] = p-\u0026gt;val; } if (p-\u0026gt;right) { q.push(p-\u0026gt;right); fa[p-\u0026gt;right-\u0026gt;val] = p-\u0026gt;val; } } } while (true) { int anc = dleves[0]; bool ok = true; for (int i = 1; i \u0026lt; dleves.size(); ++i) { if (dleves[i] != anc) { ok = false; break; } } if (ok) return mp[anc]; for (auto\u0026amp; v : dleves) { v = fa[v]; } } return root; } }; 复杂度分析\r时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。 需要进行一次层序遍历$O(n)$，以及一次向上跳跃寻找公共祖先的过程$O(logn)$。 空间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数。 需要存储二叉树每个节点的父亲节点，以及层序遍历的队列等等。 优化\r这样虽然是很朴素的想法，但实际上不够直接，仔细思考发现：\n最深子树的根节点意味着其左右子树的深度相同 答案一定在左子树或右子树中 可以用DFS来解决 代码实现\r/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: pair\u0026lt;TreeNode*, int\u0026gt; dfs(TreeNode* p) { if (!p) return {nullptr, 0}; auto [l, ln] = dfs(p-\u0026gt;left); auto [r, rn] = dfs(p-\u0026gt;right); if (ln \u0026gt; rn) return {l, ln+1}; if (rn \u0026gt; ln) return {r, rn+1}; return {p, ln+1}; } TreeNode* subtreeWithAllDeepest(TreeNode* root) { return dfs(root).first; } }; LeetCode 个人主页\rhttps://leetcode.cn/u/kalev/\n","permalink":"http://localhost:1313/posts/lc865/","tags":["LeetCode","DFS"],"title":"LeetCode 865 具有所有最深节点的最小子树"},{"categories":null,"contents":"在这篇博客中，我将分享在Kaggle的Spaceship Titanic竞赛中构建预测模型的完整流程，重点介绍如何通过余弦退火学习率调度器提升模型性能。\n竞赛概述\rSpaceship Titanic是Kaggle上的一个经典二分类问题，目标是预测乘客是否在宇宙飞船事故中被运输到另一个维度。这是一个典型的结构化数据分类问题，适合初学者入门机器学习。\n模型架构与优化策略\r核心模型结构\r我构建了一个简单的全连接神经网络作为基础模型：\nclass SpaceshipNN(nn.Module): def __init__(self, input_size): super(SpaceshipNN, self).__init__() self.fc1 = nn.Linear(input_size, 128) self.fc2 = nn.Linear(128, 64) self.fc3 = nn.Linear(64, 32) self.fc4 = nn.Linear(32, 1) self.dropout = nn.Dropout(0.3) self.relu = nn.ReLU() self.sigmoid = nn.Sigmoid() def forward(self, x): x = self.relu(self.fc1(x)) x = self.dropout(x) x = self.relu(self.fc2(x)) x = self.dropout(x) x = self.relu(self.fc3(x)) x = self.sigmoid(self.fc4(x)) return x 关键优化：余弦退火学习率调度\r为什么选择余弦退火？ 传统的学习率调度器如ReduceLROnPlateau在验证损失停止改善时降低学习率，但这种方法可能导致训练过早收敛。余弦退火则提供了一种更平滑、周期性的学习率调整方式：\n替换传统的ReduceLROnPlateau为CosineAnnealingLR\rfrom torch.optim.lr_scheduler import CosineAnnealingLR # 初始化优化器 optimizer = torch.optim.Adam(model.parameters(), lr=1e-3) # 初始化余弦退火学习率调度器 scheduler = CosineAnnealingLR(optimizer, T_max=50, eta_min=1e-6) 实现细节：\r• T_max=50：半个周期的epoch数\n• eta_min=1e-6：最小学习率\n• 每个epoch后调用scheduler.step()更新学习率\n训练流程优化\rdef train_with_cosine_annealing(model, train_loader, val_loader, epochs=100): for epoch in range(epochs): # 训练阶段 model.train() for batch in train_loader: # 前向传播、反向传播、参数更新 ... # 验证阶段 model.eval() with torch.no_grad(): ... # 更新学习率（关键步骤） scheduler.step() # 记录和打印训练信息 if epoch % 10 == 0: print(f\u0026#39;Epoch {epoch} | Train Loss: {train_loss:.4f} | \u0026#39; f\u0026#39;Val Loss: {val_loss:.4f} | LR: {current_lr:.6f}\u0026#39;) 实验结果\r通过引入余弦退火学习率调度，模型表现有了显著提升：\n初始得分：0.80360\n优化后最佳得分：0.80734（提升约0.47%）\n训练稳定性：明显改善，避免了学习率过早衰减的问题\n技术要点总结\r学习率调度的重要性：合适的学习率调度策略可以显著影响模型收敛和最终性能。\n余弦退火的优势：\n平滑的学习率变化减少训练震荡\n周期性重启帮助跳出局部最优\n无需手动设置patience参数\n实践建议：\n根据数据集大小调整T_max参数\n监控学习率变化确保合理范围\n结合早停法防止过拟合\n进一步优化方向\r虽然余弦退火带来了明显改进，但仍有进一步优化的空间：\n带热身的余弦退火：使用CosineAnnealingWarmRestarts实现更复杂的调度策略 模型架构优化：尝试更深的网络或注意力机制 特征工程：深入挖掘数据特征的相关性 结语\r通过这个项目，我深刻体会到学习率调度在深度学习中的重要性。余弦退火作为一种简单而有效的技术，值得在各类分类任务中尝试和应用。机器学习不仅是模型架构的竞赛，更是对训练细节的精心打磨。\n完整代码和详细实现请参考我的Kaggle笔记本：https://www.kaggle.com/code/kalevyang/notebooke4132da306\n","permalink":"http://localhost:1313/posts/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5spaceship-titanic%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/","tags":["神经网络","预测模型","机器学习"],"title":"神经网络实践：Spaceship Titanic预测模型优化笔记"},{"categories":null,"contents":"围棋分析系统\r从25年1月初开始学围棋，基本上在野狐围棋上对局。但是苦于野狐围棋并没有个人的黑棋白棋胜率及更多的分析数据，于是想自己实现一个基于Vue的棋局数据分析网页\n项目概述\r这是一个基于Vue 3构建的围棋对局分析系统，用于记录、管理和分析围棋对局。系统支持SGF文件导入、对局数据存储、胜率统计分析以及棋局详情查看等功能\n技术栈\r前端框架: Vue 3 + Vite 状态管理: Pinia 路由管理: Vue Router 数据可视化: Chart.js 本地存储: IndexedDB (通过idb库) SGF解析: @sabaki/sgf 语言: TypeScript 构建工具: Vite 项目结构\r├── src/ │ ├── assets/ # 静态资源 │ ├── components/ # 组件 │ ├── lib/ # 工具函数库 │ ├── router/ # 路由配置 │ ├── stores/ # 状态管理 │ ├── types/ # 类型定义 │ ├── views/ # 页面组件 │ ├── App.vue # 应用根组件 │ └── main.ts # 入口文件 ├── public/ # 公共资源 ├── .vscode/ # VSCode配置 ├── tsconfig.json # TypeScript配置 ├── vite.config.ts # Vite配置 └── package.json # 项目依赖 核心功能模块\r1. 数据存储模块\r使用IndexedDB存储对局数据 提供完整的增删改查操作 通过idb库简化IndexedDB操作 2. SGF解析模块\r解析SGF格式的对局记录 提取对局元数据（日期、对局者、结果等） 提取手数、让子、贴目等信息 3. 对局管理模块\r添加对局（支持SGF文件导入） 查看对局列表和详情 删除对局记录 筛选和排序功能 4. 数据统计模块\r计算并展示总对局数 统计黑棋和白棋胜率 展示胜率趋势图表 关键文件说明\r1. 数据存储\rsrc/lib/db.ts: 数据库初始化和配置 import { openDB } from \u0026#39;idb\u0026#39;; export const initDB = async () =\u0026gt; { return openDB(\u0026#39;GoDB\u0026#39;, 1, { upgrade(db) { if (!db.objectStoreNames.contains(\u0026#39;games\u0026#39;)) { const store = db.createObjectStore(\u0026#39;games\u0026#39;, { keyPath: \u0026#39;id\u0026#39;, autoIncrement: true }); store.createIndex(\u0026#39;date\u0026#39;, \u0026#39;date\u0026#39;); store.createIndex(\u0026#39;color\u0026#39;, \u0026#39;color\u0026#39;); store.createIndex(\u0026#39;result\u0026#39;, \u0026#39;result\u0026#39;); } } }); }; 2. 状态管理\rsrc/stores/games.ts: 棋局数据的状态管理 存储棋局列表 提供数据计算（胜率、弱点分析等） 封装数据库操作 3. SGF解析\rsrc/lib/sgf.ts: SGF文件解析工具 解析SGF字符串 提取对局信息和手数 4. 页面组件\rGameList.vue: 对局列表页面 GameDetail.vue: 对局详情页面 AddGame.vue: 添加对局页面 Statistics.vue: 数据统计页面 路由配置\rimport { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const router = createRouter({ history: createWebHistory(import.meta.env.BASE_URL), routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: HomeView, }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/AboutView.vue\u0026#39;), }, { path: \u0026#39;/game-list\u0026#39;, name: \u0026#39;game-list\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/GameList.vue\u0026#39;), }, { path: \u0026#39;/add-game\u0026#39;, name: \u0026#39;add-game\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/AddGame.vue\u0026#39;), }, { path: \u0026#39;/statistics\u0026#39;, name: \u0026#39;statistics\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/Statistics.vue\u0026#39;), }, { path: \u0026#39;/game/:id\u0026#39;, name: \u0026#39;game-detail\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/GameDetail.vue\u0026#39;), }, ], }) export default router 核心数据类型\rGame接口\rexport interface Game { id?: number; date: string; color: \u0026#39;black\u0026#39; | \u0026#39;white\u0026#39;; opponent: string; result: \u0026#39;win\u0026#39; | \u0026#39;loss\u0026#39; | \u0026#39;draw\u0026#39;; sgf: string; createdAt: string; analysis?: { winRate: number[]; mistakes: { move: number; position: string; severity: number }[]; }; } 使用说明\r安装依赖\rnpm install 开发模式启动\rnpm run dev 构建生产版本\rnpm run build 预览生产版本\rnpm run preview 功能说明\r添加对局\r点击\u0026quot;添加对局\u0026quot;导航 选择SGF格式的对局文件 系统自动解析对局信息 确认信息无误后保存对局 查看对局列表\r点击\u0026quot;对局列表\u0026quot;导航 可根据结果和颜色进行筛选 列表显示对局的关键信息，包括日期、颜色、对手、手数、让子和结果 点击\u0026quot;查看\u0026quot;按钮进入对局详情 点击\u0026quot;删除\u0026quot;按钮删除对局 查看统计数据\r点击\u0026quot;统计\u0026quot;导航 查看总对局数、黑棋胜率和白棋胜率 查看胜率趋势图表 项目特点\r本地存储: 所有数据存储在浏览器的IndexedDB中，无需后端服务 SGF支持: 支持标准SGF格式的围棋对局文件导入和解析 数据可视化: 使用Chart.js提供胜率趋势图表 响应式设计: 适配不同屏幕尺寸 类型安全: 使用TypeScript确保代码质量和开发体验 扩展方向\r增加AI分析功能 添加对局复盘功能 支持多用户数据同步 添加更多统计图表和数据洞察 实现对局评论和笔记功能 ","permalink":"http://localhost:1313/posts/%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E6%A3%8B%E5%B1%80%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%BD%91%E9%A1%B5/","tags":["Vue","棋局数据分析","前端开发"],"title":"基于Vue的棋局数据分析网页"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup\rSearch depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds\rTo search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON\rThis exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search\rstatic/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","permalink":"http://localhost:1313/page/search/","tags":null,"title":"Search Results"}]